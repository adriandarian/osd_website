# Documentation Enhancements Strategy

## Overview

Comprehensive strategy to transform OpenSeadragon's static JSDoc-generated documentation into an interactive, modern, and developer-friendly experience with advanced features like Shiki Twoslash, live code examples, search, and more.

## Current State Analysis

### Existing Documentation Issues

1. **Static HTML Only** - Generated by JSDoc 3.6.11, completely static with no interactivity
2. **No Type Inference** - Code examples don't show IntelliSense or hover information
3. **Source Links Only** - Clicking functions takes you to raw source code, not helpful explanations
4. **No Live Examples** - Can't test API calls directly in the documentation
5. **Poor Mobile Experience** - JSDoc default theme not optimized for mobile
6. **No Search** - Only browser's find-in-page functionality
7. **Flat Navigation** - Long list of links, hard to find related content
8. **No Context** - Examples don't show how APIs work together
9. **Missing Visuals** - No diagrams, flowcharts, or interactive visualizations
10. **No Version Comparison** - Can't see what changed between versions
11. **Static Code Blocks** - No syntax highlighting beyond basic HTML
12. **No Copy Functionality** - Manual copying of code examples

## Proposed Improvements

### 1. **Interactive Type-Aware Code Blocks with Shiki Twoslash**

Transform static code blocks into interactive, type-aware examples with hover information, error detection, and auto-completion hints.

#### Implementation

```typescript
// composables/useShikiTwoslash.ts
import { createTwosl as highlighter } from 'shiki-twoslash'
import { renderCodeToHTML, runTwoSlash } from 'shiki-twoslash'

export const useShikiTwoslash = () => {
  const highlightCode = async (code: string, lang: string, meta?: string) => {
    // Check if we should use twoslash
    const useTwoslash = meta?.includes('twoslash')
    
    if (useTwoslash && (lang === 'ts' || lang === 'typescript' || lang === 'js' || lang === 'javascript')) {
      // Run TypeScript compiler to get type information
      const twoslashResult = runTwoSlash(code, lang)
      
      // Render with hover information and errors
      return renderCodeToHTML(
        twoslashResult.code,
        lang,
        {
          twoslash: true,
        },
        {},
        highlighter
      )
    }
    
    // Regular syntax highlighting without twoslash
    return renderCodeToHTML(code, lang, {}, {}, highlighter)
  }
  
  return {
    highlightCode,
  }
}
```

#### Example Usage in Docs

```vue
<!-- components/docs/CodeExample.vue -->
<template>
  <div class="code-example">
    <div class="code-header">
      <span class="language">{{ language }}</span>
      <button @click="copyCode" class="copy-button">
        <Icon :name="copied ? 'carbon:checkmark' : 'carbon:copy'" />
        {{ copied ? 'Copied!' : 'Copy' }}
      </button>
      <button v-if="runnable" @click="runCode" class="run-button">
        <Icon name="carbon:play-filled" />
        Run
      </button>
    </div>
    
    <!-- Shiki Twoslash rendered HTML with type hints -->
    <div 
      class="code-content"
      v-html="highlightedCode"
    />
    
    <!-- Live output if code was run -->
    <div v-if="output" class="code-output">
      <div class="output-header">Output:</div>
      <pre>{{ output }}</pre>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  code: string
  language: string
  meta?: string
  runnable?: boolean
}>()

const { highlightCode } = useShikiTwoslash()
const highlightedCode = ref('')
const output = ref('')
const copied = ref(false)

onMounted(async () => {
  highlightedCode.value = await highlightCode(
    props.code,
    props.language,
    props.meta
  )
})

const runCode = async () => {
  // Execute code in sandbox and show output
  try {
    output.value = await executeInSandbox(props.code)
  } catch (error) {
    output.value = `Error: ${error.message}`
  }
}
</script>
```

#### Markdown Content Example

```markdown
## Using the Viewer

Here's how to create a basic OpenSeadragon viewer:

```ts twoslash
import OpenSeadragon from 'openseadragon'

// Hover over 'viewer' to see the inferred type
const viewer = OpenSeadragon({
  id: "viewer",
  //  ^? OpenSeadragon.Viewer
  prefixUrl: "/openseadragon/images/",
  tileSources: "/path/to/image.dzi",
  // Try uncommenting this to see the error:
  // invalidOption: true
  //    ^^^^^^^^^^^^^^^
  //    Error: Object literal may only specify known properties
})

// Hover to see method signature
viewer.addHandler('open', (event) => {
  //    ^^^^^^^^^^
  //    addHandler(eventName: string, handler: EventHandler): boolean
  console.log('Image opened!', event.source)
})
```\`\`\`

### 2. **Live API Playground**

Interactive playground embedded directly in documentation where users can modify OpenSeadragon configurations and see results instantly.

#### Implementation

```vue
<!-- components/docs/LivePlayground.vue -->
<template>
  <div class="live-playground">
    <div class="playground-header">
      <h3>Try it yourself</h3>
      <div class="controls">
        <button @click="resetCode">Reset</button>
        <button @click="sharePlayground">Share</button>
      </div>
    </div>
    
    <div class="playground-layout">
      <!-- Code Editor -->
      <div class="editor-pane">
        <MonacoEditor
          v-model="code"
          language="typescript"
          :options="{
            minimap: { enabled: false },
            lineNumbers: 'on',
            theme: isDark ? 'vs-dark' : 'vs-light',
            automaticLayout: true,
          }"
          @change="debounceExecute"
        />
      </div>
      
      <!-- Live Preview -->
      <div class="preview-pane">
        <div class="preview-toolbar">
          <span class="preview-label">Live Preview</span>
          <button @click="refreshPreview">
            <Icon name="carbon:restart" />
          </button>
        </div>
        
        <div class="preview-container">
          <div ref="viewerContainer" class="osd-container"></div>
        </div>
        
        <!-- Console Output -->
        <div class="console-output">
          <div class="console-header">Console</div>
          <div class="console-messages">
            <div
              v-for="(msg, idx) in consoleMessages"
              :key="idx"
              :class="['console-message', msg.type]"
            >
              {{ msg.text }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import OpenSeadragon from 'openseadragon'

const props = defineProps<{
  initialCode: string
  description?: string
}>()

const code = ref(props.initialCode)
const viewerContainer = ref<HTMLElement>()
const consoleMessages = ref<Array<{ type: string; text: string }>>([])
let viewer: OpenSeadragon.Viewer | null = null

const executeCode = () => {
  consoleMessages.value = []
  
  // Clean up existing viewer
  if (viewer) {
    viewer.destroy()
    viewer = null
  }
  
  try {
    // Create console proxy
    const customConsole = {
      log: (...args: any[]) => {
        consoleMessages.value.push({
          type: 'log',
          text: args.join(' '),
        })
      },
      error: (...args: any[]) => {
        consoleMessages.value.push({
          type: 'error',
          text: args.join(' '),
        })
      },
      warn: (...args: any[]) => {
        consoleMessages.value.push({
          type: 'warn',
          text: args.join(' '),
        })
      },
    }
    
    // Execute user code in controlled environment
    const func = new Function(
      'OpenSeadragon',
      'container',
      'console',
      code.value
    )
    
    viewer = func(OpenSeadragon, viewerContainer.value, customConsole)
  } catch (error) {
    consoleMessages.value.push({
      type: 'error',
      text: error.message,
    })
  }
}

const debounceExecute = useDebounceFn(executeCode, 1000)

onMounted(() => {
  executeCode()
})
</script>
```

### 3. **Interactive API Reference with Method Demos**

Each API method includes a live demo showing it in action.

```vue
<!-- components/docs/MethodReference.vue -->
<template>
  <div class="method-reference">
    <div class="method-header">
      <h3>
        <code>{{ method.name }}</code>
        <span class="method-signature">{{ method.signature }}</span>
      </h3>
      <div class="method-badges">
        <span v-if="method.since" class="badge">Since v{{ method.since }}</span>
        <span v-if="method.deprecated" class="badge deprecated">Deprecated</span>
        <span v-if="method.chainable" class="badge">Chainable</span>
      </div>
    </div>
    
    <div class="method-description">
      <ContentRenderer :value="method.description" />
    </div>
    
    <!-- Parameters -->
    <div v-if="method.parameters" class="method-parameters">
      <h4>Parameters</h4>
      <table class="params-table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="param in method.parameters" :key="param.name">
            <td>
              <code>{{ param.name }}</code>
              <span v-if="param.optional" class="optional">optional</span>
            </td>
            <td><TypeLink :type="param.type" /></td>
            <td><code v-if="param.default">{{ param.default }}</code></td>
            <td>{{ param.description }}</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Returns -->
    <div v-if="method.returns" class="method-returns">
      <h4>Returns</h4>
      <div class="returns-info">
        <TypeLink :type="method.returns.type" />
        <span class="returns-description">{{ method.returns.description }}</span>
      </div>
    </div>
    
    <!-- Examples -->
    <div class="method-examples">
      <h4>Examples</h4>
      
      <div v-for="(example, idx) in method.examples" :key="idx" class="example">
        <p v-if="example.description" class="example-description">
          {{ example.description }}
        </p>
        
        <!-- Tabbed code examples for different frameworks -->
        <TabGroup>
          <TabList>
            <Tab v-for="variant in example.variants" :key="variant.framework">
              {{ variant.framework }}
            </Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel v-for="variant in example.variants" :key="variant.framework">
              <CodeExample
                :code="variant.code"
                :language="variant.language"
                :runnable="variant.runnable"
              />
            </TabPanel>
          </TabPanels>
        </TabGroup>
        
        <!-- Interactive demo -->
        <div v-if="example.interactive" class="interactive-demo">
          <h5>Try it live:</h5>
          <component :is="example.component" />
        </div>
      </div>
    </div>
    
    <!-- Related Methods -->
    <div v-if="method.related" class="method-related">
      <h4>Related</h4>
      <ul>
        <li v-for="related in method.related" :key="related">
          <NuxtLink :to="`/docs/api/${related}`">{{ related }}</NuxtLink>
        </li>
      </ul>
    </div>
  </div>
</template>
```

### 4. **Smart Search with Pagefind (Free Static Search)**

Implement powerful search with keyboard shortcuts, filters, and instant results using Pagefind - a fully static search library that runs entirely in the browser.

#### Why Pagefind?
- âœ… **100% Free and Open Source**
- âœ… **Static generation** - no server required
- âœ… **Lightning fast** - search index is lazy-loaded
- âœ… **Privacy-focused** - no data sent to third parties
- âœ… **Works on GitHub Pages** - perfect for static hosting
- âœ… **Small footprint** - ~100KB for the UI, indexes load on-demand

#### Implementation

```typescript
// composables/usePagefind.ts
export const usePagefind = () => {
  const isSearchReady = ref(false)
  let pagefind: any = null
  
  const initPagefind = async () => {
    if (typeof window === 'undefined' || isSearchReady.value) return
    
    try {
      // Dynamically import Pagefind
      pagefind = await import('/pagefind/pagefind.js')
      await pagefind.init()
      isSearchReady.value = true
    } catch (error) {
      console.error('Failed to load Pagefind:', error)
    }
  }
  
  const search = async (query: string, options = {}) => {
    if (!pagefind) {
      await initPagefind()
    }
    
    const results = await pagefind.search(query, {
      sort: { score: 'desc' },
      filters: options.filters || {},
      ...options,
    })
    
    // Load detailed data for results
    const detailedResults = await Promise.all(
      results.results.map(async (result: any) => {
        const data = await result.data()
        return {
          id: result.id,
          url: data.url,
          title: data.meta.title,
          excerpt: data.excerpt,
          content: data.content,
          filters: data.filters,
          meta: data.meta,
        }
      })
    )
    
    return detailedResults
  }
  
  return {
    isSearchReady,
    initPagefind,
    search,
  }
}
```

```vue
<!-- components/docs/SearchBox.vue -->
<template>
  <div class="search-wrapper">
    <button
      class="search-button"
      @click="openSearch"
    >
      <Icon name="carbon:search" />
      <span>Search documentation...</span>
      <kbd class="search-shortcut">
        <kbd>{{ isMac ? 'âŒ˜' : 'Ctrl' }}</kbd>
        <kbd>K</kbd>
      </kbd>
    </button>
    
    <!-- Search Modal -->
    <Teleport to="body">
      <div v-if="isSearchOpen" class="search-modal">
        <div class="search-backdrop" @click="closeSearch"></div>
        
        <div class="search-container">
          <div class="search-header">
            <Icon name="carbon:search" class="search-icon" />
            <input
              ref="searchInput"
              v-model="searchQuery"
              type="text"
              placeholder="Search documentation..."
              class="search-input"
              @input="handleSearch"
              @keydown.down.prevent="highlightNext"
              @keydown.up.prevent="highlightPrevious"
              @keydown.enter.prevent="selectResult"
              @keydown.esc="closeSearch"
            >
            <button @click="closeSearch" class="close-button">
              <Icon name="carbon:close" />
            </button>
          </div>
          
          <!-- Filters -->
          <div v-if="availableFilters.length" class="search-filters">
            <button
              v-for="filter in availableFilters"
              :key="filter.key"
              :class="['filter-button', { active: activeFilters.includes(filter.key) }]"
              @click="toggleFilter(filter.key)"
            >
              {{ filter.label }}
            </button>
          </div>
          
          <!-- Results -->
          <div class="search-results">
            <div v-if="isSearching" class="search-loading">
              <Icon name="carbon:renew" class="animate-spin" />
              Searching...
            </div>
            
            <div v-else-if="searchResults.length === 0 && searchQuery" class="search-empty">
              <Icon name="carbon:search-locate" />
              No results found for "{{ searchQuery }}"
            </div>
            
            <div
              v-for="(result, idx) in searchResults"
              :key="result.id"
              :class="['search-result', { highlighted: idx === highlightedIndex }]"
              @click="navigateToResult(result)"
              @mouseenter="highlightedIndex = idx"
            >
              <div class="result-icon">
                <Icon :name="getResultIcon(result.meta.type)" />
              </div>
              
              <div class="result-content">
                <div class="result-title" v-html="highlightMatches(result.title, searchQuery)"></div>
                <div class="result-excerpt" v-html="result.excerpt"></div>
                <div class="result-path">{{ result.meta.category }} â€º {{ result.url }}</div>
              </div>
              
              <div class="result-badges">
                <span v-if="result.meta.type" class="badge">
                  {{ result.meta.type }}
                </span>
              </div>
            </div>
          </div>
          
          <!-- Footer -->
          <div class="search-footer">
            <div class="keyboard-hints">
              <span><kbd>â†‘</kbd><kbd>â†“</kbd> Navigate</span>
              <span><kbd>â†µ</kbd> Select</span>
              <span><kbd>ESC</kbd> Close</span>
            </div>
            <div class="search-powered">
              Powered by <a href="https://pagefind.app/" target="_blank">Pagefind</a>
            </div>
          </div>
        </div>
      </div>
    </Teleport>
  </div>
</template>

<script setup lang="ts">
const { search, initPagefind } = usePagefind()

const isSearchOpen = ref(false)
const searchQuery = ref('')
const searchResults = ref([])
const isSearching = ref(false)
const highlightedIndex = ref(0)
const searchInput = ref<HTMLInputElement>()
const isMac = ref(false)

const availableFilters = [
  { key: 'api', label: 'ðŸ“˜ API' },
  { key: 'guide', label: 'ðŸ“– Guide' },
  { key: 'example', label: 'ðŸ’¡ Example' },
  { key: 'tutorial', label: 'ðŸŽ“ Tutorial' },
]

const activeFilters = ref<string[]>([])

const openSearch = () => {
  isSearchOpen.value = true
  nextTick(() => {
    searchInput.value?.focus()
  })
}

const closeSearch = () => {
  isSearchOpen.value = false
  searchQuery.value = ''
  searchResults.value = []
  highlightedIndex.value = 0
}

const handleSearch = useDebounceFn(async () => {
  if (!searchQuery.value.trim()) {
    searchResults.value = []
    return
  }
  
  isSearching.value = true
  
  try {
    const filters: Record<string, string[]> = {}
    if (activeFilters.value.length) {
      filters.type = activeFilters.value
    }
    
    const results = await search(searchQuery.value, { filters })
    searchResults.value = results.slice(0, 10) // Limit to 10 results
  } catch (error) {
    console.error('Search error:', error)
  } finally {
    isSearching.value = false
  }
}, 300)

const toggleFilter = (filterKey: string) => {
  const idx = activeFilters.value.indexOf(filterKey)
  if (idx > -1) {
    activeFilters.value.splice(idx, 1)
  } else {
    activeFilters.value.push(filterKey)
  }
  handleSearch()
}

const navigateToResult = (result: any) => {
  navigateTo(result.url)
  closeSearch()
}

const selectResult = () => {
  if (searchResults.value[highlightedIndex.value]) {
    navigateToResult(searchResults.value[highlightedIndex.value])
  }
}

const highlightNext = () => {
  highlightedIndex.value = Math.min(
    highlightedIndex.value + 1,
    searchResults.value.length - 1
  )
}

const highlightPrevious = () => {
  highlightedIndex.value = Math.max(highlightedIndex.value - 1, 0)
}

const highlightMatches = (text: string, query: string) => {
  if (!query) return text
  const regex = new RegExp(`(${query})`, 'gi')
  return text.replace(regex, '<mark>$1</mark>')
}

const getResultIcon = (type: string) => {
  const icons = {
    api: 'carbon:api',
    guide: 'carbon:book',
    example: 'carbon:code',
    tutorial: 'carbon:education',
  }
  return icons[type] || 'carbon:document'
}

onMounted(() => {
  isMac.value = navigator.platform.toUpperCase().indexOf('MAC') >= 0
  
  // Preload Pagefind on idle
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => initPagefind())
  } else {
    setTimeout(() => initPagefind(), 2000)
  }
  
  // Add keyboard shortcut
  const handleKeydown = (e: KeyboardEvent) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault()
      if (isSearchOpen.value) {
        closeSearch()
      } else {
        openSearch()
      }
    }
  }
  
  window.addEventListener('keydown', handleKeydown)
  
  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeydown)
  })
})
</script>

<style scoped>
.search-modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 10vh;
}

.search-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
}

.search-container {
  position: relative;
  width: 90%;
  max-width: 640px;
  max-height: 80vh;
  background: white;
  border-radius: 12px;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.search-result.highlighted {
  background: #f3f4f6;
}

mark {
  background: #fef08a;
  color: inherit;
  font-weight: 600;
}
</style>
```

#### Build Configuration

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // ... other config
  
  hooks: {
    // Generate Pagefind index after build
    'nitro:build:public-assets': async (nitro) => {
      const { execSync } = await import('child_process')
      
      // Run Pagefind indexer
      execSync('npx pagefind --source .output/public --bundle-dir pagefind', {
        stdio: 'inherit',
      })
    },
  },
})
```

#### Alternative: Fuse.js for Client-Side Search

For smaller documentation sites, Fuse.js provides excellent fuzzy search entirely client-side:

```typescript
// composables/useFuseSearch.ts
import Fuse from 'fuse.js'

export const useFuseSearch = () => {
  const searchIndex = ref<Fuse<any> | null>(null)
  
  const initFuse = async () => {
    // Load search data (generated at build time)
    const { data } = await useFetch('/api/search-data')
    
    if (data.value) {
      searchIndex.value = new Fuse(data.value, {
        keys: [
          { name: 'title', weight: 2 },
          { name: 'description', weight: 1.5 },
          { name: 'content', weight: 1 },
          { name: 'tags', weight: 1.2 },
        ],
        threshold: 0.3,
        includeScore: true,
        includeMatches: true,
        minMatchCharLength: 2,
      })
    }
  }
  
  const search = (query: string, options = {}) => {
    if (!searchIndex.value) return []
    
    const results = searchIndex.value.search(query, {
      limit: 20,
      ...options,
    })
    
    return results.map(result => ({
      ...result.item,
      score: result.score,
      matches: result.matches,
    }))
  }
  
  return {
    initFuse,
    search,
  }
}
```

### 5. **Visual Type System Explorer**

Interactive visualization of type relationships and class hierarchies.

```vue
<!-- components/docs/TypeExplorer.vue -->
<template>
  <div class="type-explorer">
    <div class="explorer-controls">
      <input
        v-model="searchQuery"
        type="search"
        placeholder="Search types..."
      >
      <select v-model="viewMode">
        <option value="hierarchy">Hierarchy</option>
        <option value="graph">Graph</option>
        <option value="list">List</option>
      </select>
    </div>
    
    <div v-if="viewMode === 'graph'" class="type-graph">
      <!-- D3.js force-directed graph -->
      <svg ref="graphSvg" width="100%" height="600"></svg>
    </div>
    
    <div v-else-if="viewMode === 'hierarchy'" class="type-tree">
      <TypeNode
        v-for="rootType in rootTypes"
        :key="rootType.name"
        :type="rootType"
        :level="0"
      />
    </div>
    
    <div v-else class="type-list">
      <div
        v-for="type in filteredTypes"
        :key="type.name"
        class="type-card"
        @click="selectType(type)"
      >
        <div class="type-header">
          <Icon :name="getTypeIcon(type.kind)" />
          <h4>{{ type.name }}</h4>
          <span class="type-kind">{{ type.kind }}</span>
        </div>
        <p class="type-description">{{ type.description }}</p>
      </div>
    </div>
    
    <!-- Type Details Panel -->
    <Teleport to="body">
      <div v-if="selectedType" class="type-details-modal">
        <div class="modal-content">
          <div class="modal-header">
            <h2>{{ selectedType.name }}</h2>
            <button @click="selectedType = null">
              <Icon name="carbon:close" />
            </button>
          </div>
          
          <div class="modal-body">
            <!-- Full type definition with syntax highlighting -->
            <CodeExample
              :code="selectedType.definition"
              language="typescript"
              meta="twoslash"
            />
            
            <!-- Properties/Methods -->
            <div v-if="selectedType.members">
              <h3>Members</h3>
              <table class="members-table">
                <tbody>
                  <tr v-for="member in selectedType.members" :key="member.name">
                    <td><code>{{ member.name }}</code></td>
                    <td><TypeLink :type="member.type" /></td>
                    <td>{{ member.description }}</td>
                  </tr>
                </tbody>
              </table>
            </div>
            
            <!-- Inheritance chain -->
            <div v-if="selectedType.extends">
              <h3>Inheritance</h3>
              <div class="inheritance-chain">
                <span
                  v-for="(parent, idx) in selectedType.extends"
                  :key="parent"
                >
                  <TypeLink :type="parent" />
                  <Icon v-if="idx < selectedType.extends.length - 1" name="carbon:arrow-right" />
                </span>
              </div>
            </div>
            
            <!-- Usage examples -->
            <div v-if="selectedType.examples">
              <h3>Usage Examples</h3>
              <CodeExample
                v-for="(example, idx) in selectedType.examples"
                :key="idx"
                :code="example"
                language="typescript"
                meta="twoslash"
              />
            </div>
          </div>
        </div>
      </div>
    </Teleport>
  </div>
</template>

<script setup lang="ts">
import * as d3 from 'd3'

// Load type system data
const { data: typeSystem } = await useFetch('/api/docs/types')

const graphSvg = ref<SVGElement>()
const selectedType = ref(null)

const renderTypeGraph = () => {
  if (!graphSvg.value || !typeSystem.value) return
  
  const svg = d3.select(graphSvg.value)
  const width = graphSvg.value.clientWidth
  const height = 600
  
  // Create force simulation
  const simulation = d3.forceSimulation(typeSystem.value.nodes)
    .force('link', d3.forceLink(typeSystem.value.links).id(d => d.id))
    .force('charge', d3.forceManyBody().strength(-300))
    .force('center', d3.forceCenter(width / 2, height / 2))
  
  // Draw links
  const link = svg.append('g')
    .selectAll('line')
    .data(typeSystem.value.links)
    .join('line')
    .attr('stroke', '#999')
    .attr('stroke-opacity', 0.6)
  
  // Draw nodes
  const node = svg.append('g')
    .selectAll('circle')
    .data(typeSystem.value.nodes)
    .join('circle')
    .attr('r', 8)
    .attr('fill', d => getTypeColor(d.kind))
    .call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended))
    .on('click', (event, d) => {
      selectedType.value = d
    })
  
  // Add labels
  const label = svg.append('g')
    .selectAll('text')
    .data(typeSystem.value.nodes)
    .join('text')
    .text(d => d.name)
    .attr('font-size', 10)
    .attr('dx', 12)
    .attr('dy', 4)
  
  // Update positions on simulation tick
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y)
    
    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y)
    
    label
      .attr('x', d => d.x)
      .attr('y', d => d.y)
  })
}

watch(viewMode, (mode) => {
  if (mode === 'graph') {
    nextTick(() => renderTypeGraph())
  }
})
</script>
```

### 6. **Interactive Event Flow Visualizer**

Show how events propagate through the OpenSeadragon system.

```vue
<!-- components/docs/EventFlowDiagram.vue -->
<template>
  <div class="event-flow-diagram">
    <div class="diagram-header">
      <h3>Event Flow: {{ eventName }}</h3>
      <button @click="playAnimation">
        <Icon name="carbon:play-filled" />
        Play Animation
      </button>
    </div>
    
    <svg ref="diagramSvg" class="flow-diagram">
      <!-- Event source -->
      <g class="event-source" :class="{ active: currentStep >= 0 }">
        <circle cx="50" cy="100" r="30" />
        <text x="50" y="105" text-anchor="middle">User Action</text>
      </g>
      
      <!-- Event propagation path -->
      <path
        class="event-path"
        :class="{ animating: isAnimating }"
        d="M 80 100 L 200 100"
      />
      
      <!-- Handler components -->
      <g
        v-for="(handler, idx) in eventHandlers"
        :key="handler.id"
        :class="{ active: currentStep >= idx + 1 }"
        class="handler-node"
        :transform="`translate(${220 + idx * 150}, 100)`"
      >
        <rect x="-60" y="-40" width="120" height="80" rx="5" />
        <text x="0" y="-10" text-anchor="middle">{{ handler.name }}</text>
        <text x="0" y="15" text-anchor="middle" class="handler-type">
          {{ handler.type }}
        </text>
      </g>
      
      <!-- Event data inspection -->
      <foreignObject
        x="50"
        y="220"
        width="600"
        height="200"
      >
        <div class="event-inspector">
          <h4>Event Object</h4>
          <pre><code>{{ JSON.stringify(currentEventData, null, 2) }}</code></pre>
        </div>
      </foreignObject>
    </svg>
    
    <!-- Timeline control -->
    <div class="timeline-control">
      <input
        v-model="currentStep"
        type="range"
        :min="0"
        :max="eventHandlers.length"
        class="timeline-slider"
      >
      <div class="timeline-labels">
        <span>Start</span>
        <span>Handler {{ currentStep }}</span>
        <span>End</span>
      </div>
    </div>
  </div>
</template>
```

### 7. **Version Diff Viewer**

Compare API changes between versions.

```vue
<!-- components/docs/VersionDiff.vue -->
<template>
  <div class="version-diff">
    <div class="diff-controls">
      <select v-model="fromVersion">
        <option v-for="v in versions" :key="v" :value="v">v{{ v }}</option>
      </select>
      <Icon name="carbon:arrow-right" />
      <select v-model="toVersion">
        <option v-for="v in versions" :key="v" :value="v">v{{ v }}</option>
      </select>
      
      <button @click="loadDiff">Compare</button>
    </div>
    
    <div v-if="diff" class="diff-results">
      <!-- Added APIs -->
      <details v-if="diff.added.length" open>
        <summary>
          <Icon name="carbon:add" class="text-green-500" />
          Added ({{ diff.added.length }})
        </summary>
        <ul class="diff-list">
          <li v-for="item in diff.added" :key="item.path" class="added-item">
            <code>{{ item.path }}</code>
            <span class="item-type">{{ item.type }}</span>
            <NuxtLink :to="item.docUrl">View Docs â†’</NuxtLink>
          </li>
        </ul>
      </details>
      
      <!-- Changed APIs -->
      <details v-if="diff.changed.length" open>
        <summary>
          <Icon name="carbon:edit" class="text-yellow-500" />
          Changed ({{ diff.changed.length }})
        </summary>
        <ul class="diff-list">
          <li v-for="item in diff.changed" :key="item.path" class="changed-item">
            <code>{{ item.path }}</code>
            <button @click="showChanges(item)">View Changes</button>
          </li>
        </ul>
      </details>
      
      <!-- Deprecated APIs -->
      <details v-if="diff.deprecated.length">
        <summary>
          <Icon name="carbon:warning" class="text-orange-500" />
          Deprecated ({{ diff.deprecated.length }})
        </summary>
        <ul class="diff-list">
          <li v-for="item in diff.deprecated" :key="item.path" class="deprecated-item">
            <code>{{ item.path }}</code>
            <span class="migration-hint">Use {{ item.replacement }} instead</span>
          </li>
        </ul>
      </details>
      
      <!-- Removed APIs -->
      <details v-if="diff.removed.length">
        <summary>
          <Icon name="carbon:subtract" class="text-red-500" />
          Removed ({{ diff.removed.length }})
        </summary>
        <ul class="diff-list">
          <li v-for="item in diff.removed" :key="item.path" class="removed-item">
            <code>{{ item.path }}</code>
            <span class="removal-note">{{ item.reason }}</span>
          </li>
        </ul>
      </details>
    </div>
  </div>
</template>
```

### 8. **Responsive Mobile-Optimized Layout**

Modern responsive design with touch-friendly navigation.

```vue
<!-- layouts/docs.vue -->
<template>
  <div class="docs-layout">
    <!-- Mobile Header -->
    <header class="docs-header mobile-header md:hidden">
      <button @click="toggleSidebar" class="menu-button">
        <Icon name="carbon:menu" />
      </button>
      <NuxtLink to="/docs" class="logo">
        OpenSeadragon
      </NuxtLink>
      <button @click="openSearch" class="search-button">
        <Icon name="carbon:search" />
      </button>
    </header>
    
    <!-- Sidebar -->
    <aside
      class="docs-sidebar"
      :class="{ open: sidebarOpen }"
    >
      <nav class="sidebar-nav">
        <DocsSidebarNav :items="navigation" />
      </nav>
    </aside>
    
    <!-- Main Content -->
    <main class="docs-main">
      <div class="docs-content">
        <!-- Breadcrumbs -->
        <DocsBreadcrumbs />
        
        <!-- Content -->
        <article class="prose">
          <slot />
        </article>
        
        <!-- Edit on GitHub -->
        <DocsEditLink :path="page?.path" />
        
        <!-- Previous/Next Navigation -->
        <DocsPrevNext />
      </div>
      
      <!-- Table of Contents (Right Sidebar) -->
      <aside class="docs-toc hidden xl:block">
        <DocsToc :links="page?.body?.toc?.links" />
      </aside>
    </main>
    
    <!-- Mobile Navigation Overlay -->
    <Transition name="fade">
      <div
        v-if="sidebarOpen"
        class="sidebar-overlay md:hidden"
        @click="toggleSidebar"
      />
    </Transition>
  </div>
</template>

<style>
.docs-layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  grid-template-rows: auto 1fr;
  min-height: 100vh;
}

@media (min-width: 1280px) {
  .docs-layout {
    grid-template-columns: 280px 1fr 240px;
  }
}

@media (max-width: 768px) {
  .docs-layout {
    grid-template-columns: 1fr;
  }
  
  .docs-sidebar {
    position: fixed;
    left: -280px;
    top: 0;
    bottom: 0;
    width: 280px;
    z-index: 50;
    transition: left 0.3s ease;
  }
  
  .docs-sidebar.open {
    left: 0;
  }
}
</style>
```

### 9. **Interactive Configuration Builder**

Visual tool to build OpenSeadragon configurations.

```vue
<!-- components/docs/ConfigBuilder.vue -->
<template>
  <div class="config-builder">
    <div class="builder-layout">
      <!-- Options Panel -->
      <div class="options-panel">
        <h3>Configuration Options</h3>
        
        <Accordion>
          <AccordionItem
            v-for="category in optionCategories"
            :key="category.id"
            :title="category.name"
          >
            <div class="options-group">
              <div
                v-for="option in category.options"
                :key="option.key"
                class="option-field"
              >
                <label :for="option.key">
                  {{ option.label }}
                  <Tooltip>
                    <template #trigger>
                      <Icon name="carbon:information" />
                    </template>
                    <template #content>
                      {{ option.description }}
                    </template>
                  </Tooltip>
                </label>
                
                <!-- Dynamic input based on type -->
                <component
                  :is="getInputComponent(option.type)"
                  :id="option.key"
                  v-model="config[option.key]"
                  v-bind="getInputProps(option)"
                />
              </div>
            </div>
          </AccordionItem>
        </Accordion>
      </div>
      
      <!-- Preview Panel -->
      <div class="preview-panel">
        <div class="preview-header">
          <h3>Preview</h3>
          <button @click="refreshPreview">
            <Icon name="carbon:restart" />
          </button>
        </div>
        
        <div ref="previewContainer" class="preview-container"></div>
      </div>
      
      <!-- Generated Code Panel -->
      <div class="code-panel">
        <div class="code-header">
          <h3>Generated Code</h3>
          <div class="code-actions">
            <select v-model="codeFormat">
              <option value="object">Object</option>
              <option value="constructor">Constructor Call</option>
              <option value="json">JSON</option>
            </select>
            <button @click="copyCode">
              <Icon name="carbon:copy" />
              Copy
            </button>
            <button @click="downloadConfig">
              <Icon name="carbon:download" />
              Download
            </button>
          </div>
        </div>
        
        <CodeExample
          :code="generatedCode"
          language="javascript"
          :meta="codeFormat === 'json' ? '' : 'twoslash'"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const config = ref<Record<string, any>>({
  id: 'viewer',
  prefixUrl: '/openseadragon/images/',
  tileSources: '/path/to/image.dzi',
  showNavigationControl: true,
  showZoomControl: true,
  showHomeControl: true,
  showFullPageControl: true,
  // ... more defaults
})

const generatedCode = computed(() => {
  switch (codeFormat.value) {
    case 'object':
      return JSON.stringify(config.value, null, 2)
    case 'constructor':
      return `const viewer = OpenSeadragon(${JSON.stringify(config.value, null, 2)})`
    case 'json':
      return JSON.stringify(config.value, null, 2)
  }
})

// Watch config changes and update preview
watch(config, () => {
  debounceUpdatePreview()
}, { deep: true })
</script>
```

### 10. **Contextual Help System**

Inline help tooltips and hints throughout documentation.

```vue
<!-- components/docs/ContextualHelp.vue -->
<template>
  <span class="contextual-help">
    <slot />
    <Tooltip
      :disabled="!helpContent"
      placement="top"
    >
      <template #trigger>
        <button class="help-trigger">
          <Icon name="carbon:help" />
        </button>
      </template>
      
      <template #content>
        <div class="help-content">
          <div v-if="helpContent.description" class="help-description">
            {{ helpContent.description }}
          </div>
          
          <div v-if="helpContent.example" class="help-example">
            <strong>Example:</strong>
            <code>{{ helpContent.example }}</code>
          </div>
          
          <div v-if="helpContent.link" class="help-link">
            <NuxtLink :to="helpContent.link">
              Learn more â†’
            </NuxtLink>
          </div>
        </div>
      </template>
    </Tooltip>
  </span>
</template>
```

### 11. **Diagram Generator for Workflows**

Automatic generation of workflow diagrams from code.

```typescript
// utils/diagram-generator.ts
import mermaid from 'mermaid'

export const generateWorkflowDiagram = (workflow: Workflow) => {
  const diagram = `
    graph TD
    ${workflow.steps.map((step, idx) => {
      const nextStep = workflow.steps[idx + 1]
      return `
        ${step.id}[${step.label}]
        ${nextStep ? `${step.id} --> ${nextStep.id}` : ''}
      `
    }).join('\n')}
  `
  
  return diagram
}
```

```vue
<!-- components/docs/WorkflowDiagram.vue -->
<template>
  <div class="workflow-diagram">
    <div class="diagram-header">
      <h3>{{ title }}</h3>
      <button @click="exportDiagram">
        <Icon name="carbon:download" />
        Export
      </button>
    </div>
    
    <div ref="diagramContainer" class="diagram-container" v-html="renderedDiagram" />
    
    <!-- Interactive step details -->
    <div v-if="selectedStep" class="step-details">
      <h4>{{ selectedStep.label }}</h4>
      <p>{{ selectedStep.description }}</p>
      <CodeExample
        v-if="selectedStep.code"
        :code="selectedStep.code"
        language="javascript"
      />
    </div>
  </div>
</template>
```

### 12. **Performance Monitoring Dashboard**

Show performance metrics for different configurations.

```vue
<!-- components/docs/PerformanceMetrics.vue -->
<template>
  <div class="performance-metrics">
    <div class="metrics-header">
      <h3>Performance Impact</h3>
      <button @click="runBenchmark">
        <Icon name="carbon:play-filled" />
        Run Benchmark
      </button>
    </div>
    
    <div class="metrics-grid">
      <div class="metric-card">
        <div class="metric-label">Initial Load Time</div>
        <div class="metric-value">{{ metrics.loadTime }}ms</div>
        <div class="metric-bar" :style="{ width: `${metrics.loadTime / 10}%` }"></div>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Tile Rendering</div>
        <div class="metric-value">{{ metrics.renderTime }}ms</div>
        <div class="metric-bar" :style="{ width: `${metrics.renderTime / 5}%` }"></div>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">Memory Usage</div>
        <div class="metric-value">{{ metrics.memoryUsage }}MB</div>
        <div class="metric-bar" :style="{ width: `${metrics.memoryUsage / 2}%` }"></div>
      </div>
      
      <div class="metric-card">
        <div class="metric-label">FPS</div>
        <div class="metric-value">{{ metrics.fps }}</div>
        <div class="metric-bar" :style="{ width: `${metrics.fps * 1.66}%` }"></div>
      </div>
    </div>
    
    <!-- Performance Chart -->
    <div class="performance-chart">
      <canvas ref="chartCanvas"></canvas>
    </div>
    
    <!-- Recommendations -->
    <div v-if="recommendations.length" class="recommendations">
      <h4>Optimization Suggestions</h4>
      <ul>
        <li v-for="rec in recommendations" :key="rec.id">
          <Icon :name="rec.icon" />
          {{ rec.message }}
          <NuxtLink v-if="rec.link" :to="rec.link">Learn more</NuxtLink>
        </li>
      </ul>
    </div>
  </div>
</template>
```

## Implementation Roadmap

### Phase 1: Foundation (Weeks 1-2)
- [ ] Set up Nuxt Content for documentation
- [ ] Configure Shiki Twoslash
- [ ] Create base documentation layout
- [ ] Implement search with Pagefind (free static search)

### Phase 2: Interactive Features (Weeks 3-4)
- [ ] Build live playground component
- [ ] Create interactive code examples
- [ ] Implement configuration builder
- [ ] Add type-aware tooltips

### Phase 3: Advanced Features (Weeks 5-6)
- [ ] Type system explorer
- [ ] Event flow visualizer
- [ ] Version diff viewer
- [ ] Performance monitoring dashboard

### Phase 4: Content Migration (Weeks 7-8)
- [ ] Parse existing JSDoc comments
- [ ] Generate markdown from API documentation
- [ ] Add examples to all API methods
- [ ] Create workflow diagrams

### Phase 5: Polish & Launch (Week 9)
- [ ] Mobile optimization
- [ ] Accessibility audit
- [ ] Performance optimization
- [ ] Documentation and launch

## Technical Stack

### Core
- **Nuxt 3** - Framework
- **Nuxt Content** - Documentation management
- **Vue 3** - UI components

### Code Display
- **Shiki Twoslash** - Type-aware syntax highlighting
- **Monaco Editor** - In-browser code editor
- **Prism/Highlight.js** - Fallback syntax highlighting

### Search
- **Pagefind** - Free static search (primary)
- **Fuse.js** - Client-side fuzzy search (alternative/fallback)

### Visualizations
- **D3.js** - Data visualizations and graphs
- **Mermaid** - Diagram generation
- **Cytoscape.js** - Type system graphs

### Testing & Performance
- **Vitest** - Unit testing
- **Playwright** - E2E testing
- **Lighthouse CI** - Performance monitoring

## Success Metrics

- **Search Usage**: 50%+ of users use search feature
- **Interactive Examples**: 30%+ click-through rate on runnable examples
- **Mobile Traffic**: 25%+ increase in mobile documentation views
- **Time to Answer**: 50% reduction in time to find API information
- **User Satisfaction**: > 4.5/5 stars in feedback
- **Playground Usage**: 1000+ unique playground sessions/month
- **Type Explorer**: 20%+ of API viewers explore type system

## Future Enhancements

- **AI-Powered Code Assistance**: Suggest code completions using GPT
- **Video Tutorials**: Embedded video explanations
- **Multi-Language Support**: i18n for documentation
- **Community Examples**: User-submitted code examples
- **Plugin Documentation**: Standardized plugin docs format
- **Real-Time Collaboration**: Share and edit playground sessions
- **Performance Profiles**: Compare configurations side-by-side
- **Dark Mode**: Full dark mode support with preference persistence
